# IPC Design

As a microkernel, the most important syscalls must be the IPC syscalls, since each service is running in its own address space and IPC syscalls serve as the bridge between service provider and consumer.

As a minimalistic, we only provide 3 IPC syscalls:

- request: Request a service to do something.
- receive: Service provider receives a request from a consumer.
- respond: Service provider responds to a consumer.

In fact, all our [unix-like syscalls](syscall.md) are implemented mostly by these 3 syscalls, except that the kernel may automatically do some work for you (arranging the IPCs and copying data, like sys_fork). You may just treat them as a sequence of IPCs arranged by the kernel.

## Summary

We use a opaque IPC message design, which provides much flexibility and optimization opportunities for the kernel. The IPC syscalls are simple and minimalistic, but powerful enough to support all the other syscalls.

To speed up the IPC, we make some small optimizations, like directly switch to the service provider without going through the scheduler, if the service provider is waiting for some request. Our design of IPC also provides many opportunities to optimize the cost of passing messages.

We also provide a powerful user library to handle the IPC for you, so that you don't need to worry about the details of the IPC syscalls (you don't need to know what the handle is implemented).

## IPC Message

To make the IPC as simple and opaque as possible, we design a special interface for the IPC message format.

The mode of the message is passed in a register, which will tell the kernel how to handle the message (whether to wrap them in a kernel buffer, or simply holding them in registers).

Currently, our IPC message supports these modes:

- in register: the message are passed by registers, which is the fastest way (Thanks to the rich registers provided by RISC-V, we may pass many short messages in registers).
- in buffer: the message are passed in a pointer with a length, which is the traditional way that many Unix-like systems use.

We plan to add more modes:

- asynchronous send: the message are passed in some format, but asynchronously. The service provider may respond to the consumer later.
- shared memory: the message are passed in a shared memory area, which is a common way to pass large messages (zero-copy).
- mapping pages: the message will be passed by building memory mapping (mmap) in the service provider's address space. This is the most efficient way to pass extremly large messages for one-time use (compared to shared memory).
- ...

### Benifits

With this design, the IPC message is actually opaque to the kernel: the kernel doesn't know what the message is, it just passes the message to the service provider and consumer, performing some necessary operations (like copying the message from the consumer to the provider).

Also, it provides much flexibility for the kernel. Take the `write` syscall as an example. Since it's traditional unix-like syscall, the input message is a pointer and a length. However, when the kernel sends the message to the service provider (File System), it may choose different ways to pass the message:

- If the message is small, the kernel may choose to pass the message in registers, which is faster.
- If the message is medium, the kernel can pass it just like the traditional way, in a buffer.
- If the message is large, the kernel may even radically build a page table mapping area in the provider's address space, so that there's no need to copy the message at all.

As you can see, the simple opaque design actually provides much flexibility and optimization opportunities for the kernel.

Even more, this design has great scalability. If we want to add new modes to the message (like shared memory, asynchronous send, etc.), we can just add new modes to the message, and change the kernel data transfer functions.

## IPC Syscall

### handle

A handle is the only marker of a service. For service provider, it should hold the handle to provide service. When responding, the handle should be passed to the kernel to wake up the blocking request.

A handle will only be generated by the kernel for each request. It's unique and positive. The return value of handle may have special meanings:

- If the handle is **0**, it means the service requires no response, so the service provider should not respond.
- If the handle is **negative**, it means that the service we received is incomplete. This is possibly due to the fact that the buffer provided by the service provider is too small to hold the message. In this case, the service provider should enlarge the buffer and call the syscall again.
- Normally, the handle is positive, which means the service is complete and the service provider should respond.

Note that there isn't a physical representation of the handle. It's just an abstraction. It can be any arbitary positive integer, and only holds for current process (that means, it cannot be stored in a file or passed to another process).

### request

Request a service to do something.

In this syscall, consumer makes an attempt to request targeted service. The kernel will automatically generate the handle for the request, and pass the message to the service provider.

As a microkernel, there's much such request. To speed up the request, we make some small optimizations: if the service provider is waiting for some request, we will directly switch to the service provider, without going through the scheduler. To ensure the fairness, the time slice is shared between the service provider and the consumer.

### receive

Service provider receives a request from a consumer.

In this syscall, service provider waits for a request from the consumer. If the request is already there, the kernel will return to user space. Otherwise, it will block until some request arrives.

Receiver may provide some buffer to try to hold the message, but the kernel may ignore that (e.g, the message is passed in registers instead of in the buffer). Receiver should check the return value type of the message and act accordingly. (Luckily, we have provided a user library to handle this for you).

### respond

Service provider responds to a consumer.

In this syscall, service provider responds to the consumer. The kernel will pass the message to the consumer, and wake up the consumer.

For asynchronous service, when consumer requests for the service, the kernel will not generate a handle, and there will be no handle received by the service provider. In this case, the service provider should not respond. Still, we have powerful user library to handle this for you.

## Example

We implemented a tiny multithread library to demonstrate the strength of our IPC design. The mutex library is implemented completely in user space.

For user library, we just add some wrappings for the IPC syscalls to perform normal mutex operations (like lock, unlock, etc).

For the service provider (process manager), it just need to add some data structures to hold the mutexes and the waiting threads. It is implemented in user mode, making the kernel more tolerant to bugs. (If fail, we may just restart the process manager, althought the old services will be lost).

We don't need to modify the kernel at all. The kernel just provides the IPC syscalls and the user library will handle the rest.

## Future Work

We may implement more IPC modes in the future, like shared memory, asynchronous send, etc.

In kernel, we may optimize some traditional syscalls in different scenarios (e.g. write short message in registers, write large message in shared memory, etc).

In user, we may also add wrappings for IPCs to make it easier to use and optimize the message transfer mode to speed up even more radically.
